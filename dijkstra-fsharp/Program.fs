open System

[<EntryPoint>]
let main argv =
    let dijkstra begin_point end_point list_of_points =
        // "максимальное" значение
        let infinity = 1000000;

        // ищет в таблице результатов нужный
        let find_length end_point result_list = 
            let result = List.filter (fun (point, lenght) -> point = end_point) result_list
            match result with
            | [] -> -1
            | head::_ -> snd head

        // проверяет, была ли вершина посещена
        let rec belongs_to point visited =
            match point, visited with
            | _, [] -> false
            | point, (( curpoint, _)::visited_tail) -> if (point = curpoint) then true else belongs_to point visited_tail
            
        // возвращает список текущих расстояний до вершин
        let rec compound_path arr visited =
            match arr with
            | [] -> []
            | (point1, point2, length)::tail -> 
                    let current_lenght point = List.fold (fun acc elem -> if ((fst elem) = point) then (snd elem) else acc) infinity visited
                    (point2, (current_lenght point1) + length)::(compound_path tail visited)

        // возвращает пару с минимальным путём среди пар (вершина, путь)
        let return_min_couple arr =
            match arr with
            | [] -> (infinity, infinity)
            | _ -> List.fold  (fun acc elem -> if ((snd acc) > (snd elem)) then elem else acc) (infinity, infinity) arr

        // поиск ближайшей соседней вершины
        let check_neighbors point visited list =
            let b = if (belongs_to point visited) then list else []
            let a = List.filter (fun (x, y, z) -> not (belongs_to y visited)) b
            let c = compound_path a visited
            return_min_couple c
        
        // алгоритм Дейкстры, ищет кратчайшие пути от начальной до каждой из вершин, 
        // в visited должна уже быть начальная вершина и длина до неё 0
        let rec dijkstra_ s list visited =
            let tempcouple = check_neighbors s visited list
            if (fst tempcouple = infinity && snd tempcouple = infinity)
            then visited
            else dijkstra_ (fst tempcouple) list (tempcouple::visited)

        find_length end_point (dijkstra_ begin_point list_of_points [(begin_point, 0)])
    
    let tests =
        // ====================================== тесты ======================================
        // простой тест со графом из википедии
        let simpletest = [(1, 2, 7); (1, 3, 9);
        (1, 6, 14); (2, 3, 10); 
        (2, 4, 15); (3, 4, 11); 
        (3, 6, 2); (4, 5, 6); (6, 5, 9)]
        // маленький граф с циклом
        let shorttestcycle = [(1, 2, 1); (2, 3, 1); (3, 1, 1)]
        // маленький граф с большими цифрами
        let shortbutbigtest = [(1, 2, 1000); (1, 3, 3000);
            (1, 6, 6000); (2, 3, 3000); 
            (2, 4, 4000); (3, 4, 4000); 
            (3, 6, 6000); (4, 5, 5000); (6, 5, 5000)]
        // пустой граф
        let emptytest = []
        // граф с повторениями
        let replaytest = [(1,4,2);(1,3,4);(1,2,3);(2,6,3);(3,6,6);(4,5,5);(4,6,2);(5,6,7);(5,9,12);(6,5,1);(6,7,8);(6,8,7);(7,10,4);(8,10,3);(9,8,6);(9,10,11);
                          (1,4,2);(1,3,4);(1,2,3);(2,6,3);(3,6,6);(4,5,5);(4,6,2);(5,6,7);(5,9,12);(6,5,1);(6,7,8);(6,8,7);(7,10,4);(8,10,3);(9,8,6);(9,10,11);
                          (1,4,2);(1,3,4);(1,2,3);(2,6,3);(3,6,6);(4,5,5);(4,6,2);(5,6,7);(5,9,12);(6,5,1);(6,7,8);(6,8,7);(7,10,4);(8,10,3);(9,8,6);(9,10,11);
                          (1,4,2);(1,3,4);(1,2,3);(2,6,3);(3,6,6);(4,5,5);(4,6,2);(5,6,7);(5,9,12);(6,5,1);(6,7,8);(6,8,7);(7,10,4);(8,10,3);(9,8,6);(9,10,11);
                          (1,4,2);(1,3,4);(1,2,3);(2,6,3);(3,6,6);(4,5,5);(4,6,2);(5,6,7);(5,9,12);(6,5,1);(6,7,8);(6,8,7);(7,10,4);(8,10,3);(9,8,6);(9,10,11);
                          (1,4,2);(1,3,4);(1,2,3);(2,6,3);(3,6,6);(4,5,5);(4,6,2);(5,6,7);(5,9,12);(6,5,1);(6,7,8);(6,8,7);(7,10,4);(8,10,3);(9,8,6);(9,10,11);
                          (1,4,2);(1,3,4);(1,2,3);(2,6,3);(3,6,6);(4,5,5);(4,6,2);(5,6,7);(5,9,12);(6,5,1);(6,7,8);(6,8,7);(7,10,4);(8,10,3);(9,8,6);(9,10,11);
                          (1,4,2);(1,3,4);(1,2,3);(2,6,3);(3,6,6);(4,5,5);(4,6,2);(5,6,7);(5,9,12);(6,5,1);(6,7,8);(6,8,7);(7,10,4);(8,10,3);(9,8,6);(9,10,11);
                          (1,4,2);(1,3,4);(1,2,3);(2,6,3);(3,6,6);(4,5,5);(4,6,2);(5,6,7);(5,9,12);(6,5,1);(6,7,8);(6,8,7);(7,10,4);(8,10,3);(9,8,6);(9,10,11);]
        // большой граф
        let largetest = [(1, 5, 60); (1, 7, 96); (1, 8, 77); (1, 10, 48); (1, 15, 89);
                        (1, 16, 20); (1, 23, 62); (2, 4, 53); (2, 9, 24); (2, 15, 9);
                        (2, 17, 64); (2, 18, 50); (2, 20, 88); (2, 23, 95); (2, 24, 74);
                        (2, 27, 82); (3, 5, 43); (3, 7, 33); (3, 11, 41); (3, 14, 80);
                        (3, 16, 80); (3, 22, 18); (3, 24, 10); (4, 8, 6); (4, 9, 18);
                        (4, 10, 86); (4, 13, 90); (4, 16, 66); (4, 23, 23); (4, 24, 82);
                        (4, 25, 50); (4, 26, 9); (4, 27, 86); (4, 28, 30); (4, 30, 73);
                        (5, 7, 31); (5, 21, 36); (5, 22, 64); (5, 25, 67); (5, 30, 30);
                        (6, 15, 23); (6, 16, 25); (6, 17, 4); (6, 21, 20); (6, 25, 37);
                        (6, 30, 81); (7, 9, 38); (7, 10, 38); (7, 18, 61); (7, 19, 10);
                        (7, 23, 70); (7, 27, 92); (8, 9, 73); (8, 10, 9); (8, 12, 71);
                        (8, 19, 21); (8, 20, 4); (8, 27, 71); (9, 10, 55); (9, 11, 41);
                        (9, 16, 8); (9, 18, 13); (9, 19, 46); (9, 20, 75); (9, 21, 74); 
                        (9, 22, 99); (9, 25, 19); (9, 28, 75); (9, 30, 83); (10, 11, 91); 
                        (10, 12, 84); (10, 14, 18); (10, 16, 22); (10, 19, 12); (10, 22, 35); 
                        (10, 23, 43); (10, 26, 48); (10, 27, 62); (11, 14, 71); (11, 27, 75); 
                        (12, 14, 9); (12, 20, 3); (12, 22, 87); (12, 24, 32); (12, 26, 38); 
                        (12, 30, 60); (13, 24, 28); (13, 26, 69); (13, 28, 26); (14, 15, 5); 
                        (14, 17, 97); (14, 19, 19); (14, 20, 9); (14, 22, 66); (14, 23, 52); 
                        (14, 25, 63); (14, 26, 1); (14, 27, 71); (14, 28, 85); (15, 16, 37); 
                        (15, 17, 57); (15, 19, 38); (15, 21, 28); (15, 23, 24); (15, 26, 46); 
                        (15, 27, 98); (15, 30, 26); (16, 18, 37); (16, 21, 29); (16, 29, 98); 
                        (17, 19, 89); (17, 23, 45); (17, 24, 74); (17, 29, 66); (18, 19, 7); 
                        (18, 20, 34); (18, 25, 74); (18, 29, 88); (18, 30, 78); (19, 21, 14); 
                        (19, 22, 5); (19, 23, 96); (19, 25, 15); (19, 26, 50); (20, 21, 4); 
                        (20, 24, 66); (20, 26, 18); (20, 30, 84); (21, 22, 82); (21, 27, 56); 
                        (22, 23, 17); (22, 25, 74); (22, 28, 28); (23, 25, 20); (23, 26, 86); 
                        (23, 30, 80); (24, 26, 68); (24, 30, 56); (25, 29, 32); (26, 27, 13); 
                        (26, 29, 36); (27, 30, 95); (29, 30, 14)]
        // большой случайный граф
        let largerandomtest =
            [for i in 1 .. 99 do
                for j in (i+1) .. 100 ->
                    if ((new System.Random()).Next(1, 4) = 1)
                    then (i, j, (new System.Random()).Next(1, 100))
                    else (1, 1, 1)]
        
        // выводит список
        let rec print_list list acc =
            match list with
            | [] -> acc
            |(head::tail) ->
                    printf "%A" head
                    print_list tail acc+1
        // запускает тесты
        let test test_name begin_point end_point test_list =
            let timer = System.Diagnostics.Stopwatch.StartNew()
            let result = dijkstra begin_point end_point test_list
            timer.Stop()
            printfn "Тест \"%s\":" test_name
            printfn ""
            print_list test_list 0 |> ignore
            printfn ""
            printfn "Результат (расстояние из вершины %A в вершину %A): %A" begin_point end_point result
            printfn "Затраченное время: %O" timer.Elapsed
            printfn ""
            printfn "============================================================================="
            printfn ""
            0
        test "Маленький граф с циклом" 1 3 shorttestcycle |> ignore
        test "Граф из википедии" 1 5 simpletest |> ignore
        test "Маленький граф с циклом" 1 3 shorttestcycle |> ignore
        test "Маленький граф с большими цифрами" 1 5 shortbutbigtest |> ignore
        test "Пустой граф" 1 3 emptytest |> ignore
        test "Граф с повторениями" 1 10 replaytest |> ignore
        test "Большой граф" 1 30 largetest |> ignore
        test "Большой случайный граф" 1 100 largerandomtest |> ignore
        0

    let res = tests

    0
